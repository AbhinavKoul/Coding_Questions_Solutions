#include<iostream>
#include<vector>
#include<bitset>
using namespace std;

vector <int> numToVec(int N) {   
    vector<int> digit;
    while(N != 0) {
        digit.push_back(N % 10);
        N = N / 10;
    }
    if(digit.size() == 0)
        digit.push_back(0);

    reverse(digit.begin(), digit.end());
    return digit; 
}

int solve(vector<int> &A, int B, int C) {
    vector<int> digit;
    int  d, d2;
    // Convert number to digit array
    digit = numToVec(C);
    d = A.size();

    //Case 1
    if(B > digit.size()  || d == 0)
        return 0;

    // Case 2
    else if(B < digit.size()) {
        // contain 0
        if(A[0] == 0 && B != 1)
            return (d - 1) * pow(d, B - 1);
        else 
            return pow(d, B);
    }

    //Case 3
    else {

    /*
    dp[i] stores the number of numbers having length 'i' < first 'i' digits of C

    Elements in dp[i] can be generated by two cases :

        i) For all the Numbers whose First(i - 1) is less than First (i-1) of C, we can put any digit at iâ€™th index.
        Hence, dp[i] += (dp[i-1] * d)

        ii) For all the Numbers whose First (i - 1) is same as First (i - 1) of C, we can only put those digits which are smaller than digit[i] .
        Hence , dp[i] += lower[digit[i]]
    Final answer will be dp[B]

    eg. 
    a = {0,1,2,3,4}  ==> lower = [0,1,2,3,4,5,5,5,5]
        4 5 4   B = 3  ==> dp[4] will be created

        1) 4 --> will select only 3 elements ie. all till 399; now we need to add elemets from 4 _ _
            dp[1] = 3
        2) 45 --> 3 * 5 = 15 choices till 3 as starting.. now for 40,41,42,43,44(ie. 5 == lower[5]) which we need to add

            dp[2] = 15 + 5 = 20
        3) 454 --> 20 * 5 = 100.. since 5 is not in set.. thus all are counted as max will be 4 4 4
            dp[3] = 100

    */
          vector<int> dp(B+1,0),lower(11,0);

          for(int i = 0; i < d; i++)
              lower[A[i] + 1] = 1;

          for(int i = 1; i <= 10; i++)
              lower[i] = lower[i-1] + lower[i]; 

          bool flag = true;
          dp[0] = 0;
          for(int i = 1; i <= B; i++) {
              d2 = lower[digit[i-1]];
              dp[i] = dp[i-1] * d;

              // For first index we can't use 0
             if(i == 1 &&  A[0] == 0 && B != 1)
                 d2 = d2 - 1;

             //Whether (i-1) digit of generated number can be equal to (i - 1) digit of C.
             if(flag)
                 dp[i] += d2;
             //Is digit[i - 1] present in A ?
                flag = flag & (lower[digit[i-1] + 1] == lower[digit[i-1]] + 1);// it is present if we add 1 to prefix sum array than before one.
        }
    return dp[B];                   
    } 
}

